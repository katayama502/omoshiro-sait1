<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic God Controller - Audio Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #video-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 140px;
            height: 105px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            transform: scaleX(-1);
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        #video-container:hover { opacity: 0.9; }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #ui-overlay {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 0 15px rgba(0,0,0,0.9);
            z-index: 5;
        }

        #audio-unlock {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 200;
            cursor: pointer;
            text-align: center;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #020205 0%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            transition: opacity 1s;
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 2px solid rgba(255,255,255,0.02);
            border-radius: 50%;
            border-top: 2px solid #00d2ff;
            animation: spin 0.6s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.05);
            padding: 12px 24px;
            border-radius: 40px;
            color: #00d2ff;
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 210, 255, 0.2);
            z-index: 20;
        }

        .instructions {
            position: absolute;
            top: 85px;
            right: 25px;
            color: rgba(255,255,255,0.4);
            font-size: 10px;
            text-align: right;
            line-height: 1.8;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="audio-unlock">
        <div>
            <h2 style="letter-spacing: 5px;">COSMIC ENGINE READY</h2>
            <p>画面をクリックして宇宙の音を解放してください</p>
        </div>
    </div>

    <div id="loading" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <p>音響粒子を生成中...</p>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <div id="ui-overlay">
        <h1 style="margin-bottom: 5px; letter-spacing: 6px; font-weight: 100; font-size: 2.5em;">OMNIPOTENCE</h1>
        <p style="opacity: 0.5; font-size: 12px; letter-spacing: 2px;">視覚と音響が共鳴する全知全能の体験</p>
    </div>

    <div id="status" class="status-badge">AWAITING AUDIO</div>
    <div class="instructions">
        <b>COMMANDS:</b><br>
        - 指先を動かす: クリスタル・トーン<br>
        - 両手を重ねる: ワームホール・ハミング<br>
        - 両手を広げる: ギャラクティック・パルス<br>
        - 素早いスワイプ: 流星の残響<br>
    </div>

    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- AUDIO ENGINE ---
        class CosmicAudio {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.mainGain = this.ctx.createGain();
                this.mainGain.gain.value = 0.5;
                this.mainGain.connect(this.ctx.destination);
                
                // Wormhole sound source
                this.whOsc = this.ctx.createOscillator();
                this.whOsc.type = 'sine';
                this.whGain = this.ctx.createGain();
                this.whGain.gain.value = 0;
                this.whOsc.connect(this.whGain);
                this.whGain.connect(this.mainGain);
                this.whOsc.start();
                
                this.bgm();
            }

            bgm() {
                const noise = this.ctx.createBufferSource();
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                noise.loop = true;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 100;
                const g = this.ctx.createGain();
                g.gain.value = 0.05;
                noise.connect(filter);
                filter.connect(g);
                g.connect(this.mainGain);
                noise.start();
            }

            playStardust() {
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800 + Math.random() * 1000, this.ctx.currentTime);
                g.gain.setValueAtTime(0.02, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
                osc.connect(g);
                g.connect(this.mainGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            }

            updateWormhole(intensity, dist) {
                const targetFreq = 50 + (1 - dist/2.5) * 150;
                this.whOsc.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1);
                this.whGain.gain.setTargetAtTime(intensity * 0.2, this.ctx.currentTime, 0.1);
            }

            playPop() {
                const noise = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                noise.type = 'triangle';
                noise.frequency.setValueAtTime(150, this.ctx.currentTime);
                noise.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1);
                g.gain.setValueAtTime(0.3, this.ctx.currentTime);
                g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
                noise.connect(g);
                g.connect(this.mainGain);
                noise.start();
                noise.stop(this.ctx.currentTime + 0.2);
            }

            playPulse() {
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, this.ctx.currentTime);
                g.gain.setValueAtTime(0.8, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
                osc.connect(g);
                g.connect(this.mainGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 2);
            }

            playShootingStar() {
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(2000, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 1);
                g.gain.setValueAtTime(0.05, this.ctx.currentTime);
                g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                osc.connect(filter);
                filter.connect(g);
                g.connect(this.mainGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }
        }

        let audio;
        document.getElementById('audio-unlock').addEventListener('click', () => {
            audio = new CosmicAudio();
            document.getElementById('audio-unlock').style.display = 'none';
            document.getElementById('loading').style.display = 'flex';
            init();
        });

        // --- THREE.JS ENGINE ---
        let scene, camera, renderer, starField, planetParticles, ring;
        let handPoints = []; 
        let extraPlanets = []; 
        let trailParticles = [];
        let shootingStars = [];

        let targetZoom = 15;
        let currentZoom = 15;
        let nebulaColor = new THREE.Color(0x000000);
        let pulseIntensity = 0;
        let isWormhole = false;
        let wormholePos = new THREE.Vector3();
        let lastHandPos = new THREE.Vector3();

        const STAR_COUNT = 40000;
        const PLANET_PARTICLE_COUNT = 20000;
        const PLANET_RADIUS = 3.2;
        const EXTRA_PLANET_COUNT = 20;

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = currentZoom;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            createMassiveStarfield();
            createAdvancedPlanet();
            createSatelliteRing();
            createExtraPlanets();

            const pLight = new THREE.PointLight(0xffffff, 3, 100);
            pLight.position.set(30, 30, 30);
            scene.add(pLight);
            scene.add(new THREE.AmbientLight(0x050515));

            setupHandTracking();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createMassiveStarfield() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(STAR_COUNT * 3);
            const initPos = new Float32Array(STAR_COUNT * 3);
            const colors = new Float32Array(STAR_COUNT * 3);
            for (let i = 0; i < STAR_COUNT; i++) {
                const x = (Math.random() - 0.5) * 350, y = (Math.random() - 0.5) * 350, z = (Math.random() - 0.5) * 350;
                pos.set([x, y, z], i * 3);
                initPos.set([x, y, z], i * 3);
                const c = new THREE.Color();
                c.setHSL(0.5 + Math.random() * 0.2, 0.7, 0.8);
                colors.set([c.r, c.g, c.b], i * 3);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('initialPosition', new THREE.BufferAttribute(initPos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starField = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.1, vertexColors: true, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending }));
            scene.add(starField);
        }

        function createAdvancedPlanet() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(PLANET_PARTICLE_COUNT * 3);
            const base = new Float32Array(PLANET_PARTICLE_COUNT * 3);
            const vels = new Float32Array(PLANET_PARTICLE_COUNT * 3);
            for (let i = 0; i < PLANET_PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PLANET_PARTICLE_COUNT);
                const theta = Math.sqrt(PLANET_PARTICLE_COUNT * Math.PI) * phi;
                const x = PLANET_RADIUS * Math.cos(theta) * Math.sin(phi);
                const y = PLANET_RADIUS * Math.sin(theta) * Math.sin(phi);
                const z = PLANET_RADIUS * Math.cos(phi);
                pos.set([x, y, z], i * 3); base.set([x, y, z], i * 3); vels.set([0, 0, 0], i * 3);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('basePosition', new THREE.BufferAttribute(base, 3));
            geo.setAttribute('velocity', new THREE.BufferAttribute(vels, 3));
            planetParticles = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.04, color: 0x00d2ff, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending }));
            scene.add(planetParticles);
        }

        function createSatelliteRing() {
            const count = 3000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 5.5 + Math.random() * 1.5;
                pos.set([Math.cos(angle)*radius, (Math.random()-0.5)*0.2, Math.sin(angle)*radius], i*3);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            ring = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0x00d2ff, size: 0.02, transparent: true, opacity: 0.4 }));
            scene.add(ring);
        }

        function createExtraPlanets() {
            const colors = [0x00d2ff, 0xff00cc, 0xffcc00, 0x00ffcc];
            for (let i = 0; i < EXTRA_PLANET_COUNT; i++) {
                const size = 0.4 + Math.random() * 0.8;
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(size, 16, 16), new THREE.MeshPhongMaterial({ color: colors[i % colors.length], emissiveIntensity: 0.3, wireframe: true }));
                const angle = Math.random() * Math.PI * 2;
                const dist = 12 + Math.random() * 15;
                mesh.position.set(Math.cos(angle)*dist, (Math.random()-0.5)*20, Math.sin(angle)*dist);
                mesh.userData = { vel: new THREE.Vector3((Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03), originalPos: mesh.position.clone(), isPopped: false, size };
                scene.add(mesh);
                extraPlanets.push(mesh);
            }
        }

        function spawnStardust(pos) {
            if(Math.random() < 0.2 && audio) audio.playStardust();
            const count = 3;
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.04, 4, 4), new THREE.MeshBasicMaterial({ color: 0x00d2ff, transparent: true, opacity: 0.8 }));
                mesh.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*0.4, (Math.random()-0.5)*0.4, (Math.random()-0.5)*0.4));
                scene.add(mesh);
                trailParticles.push({ mesh, life: 1.0, vel: new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02) });
            }
        }

        function spawnShootingStar() {
            if(audio) audio.playShootingStar();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            mesh.position.set((Math.random()-0.5)*60, (Math.random()-0.5)*60, -60);
            mesh.lookAt(new THREE.Vector3(0,0,0));
            scene.add(mesh);
            shootingStars.push({ mesh, life: 1.0 });
        }

        function setupHandTracking() {
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(onResults);
            const video = document.getElementById('input_video');
            const cameraPipe = new Camera(video, { onFrame: async () => await hands.send({ image: video }), width: 640, height: 480 });
            cameraPipe.start().then(() => {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => document.getElementById('loading').style.display = 'none', 1000);
            });
        }

        function onResults(results) {
            handPoints = [];
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                let centers = [];
                results.multiHandLandmarks.forEach((landmarks, hIdx) => {
                    const tipIndices = [4, 8, 12, 16, 20];
                    tipIndices.forEach(idx => {
                        const pos = convertTo3D(landmarks[idx]);
                        handPoints.push(pos);
                        if(Math.random() > 0.4) spawnStardust(pos);
                    });
                    const wrist = convertTo3D(landmarks[0]);
                    centers.push(wrist);
                    if (hIdx === 0) {
                        const d = Math.sqrt(Math.pow(landmarks[4].x-landmarks[8].x,2)+Math.pow(landmarks[4].y-landmarks[8].y,2));
                        targetZoom = 25 - (d * 50);
                        targetZoom = Math.max(5, Math.min(35, targetZoom));
                        const speed = wrist.distanceTo(lastHandPos);
                        if (speed > 1.3) spawnShootingStar();
                        lastHandPos.copy(wrist);
                    }
                });

                if(centers.length === 2) {
                    const d = centers[0].distanceTo(centers[1]);
                    if(d < 2.5) {
                        isWormhole = true;
                        wormholePos.lerpVectors(centers[0], centers[1], 0.5);
                        if(audio) audio.updateWormhole(1.0, d);
                    } else if (d > 12.0) {
                        if(pulseIntensity < 0.1 && audio) audio.playPulse();
                        pulseIntensity = 1.0;
                        isWormhole = false;
                        if(audio) audio.updateWormhole(0, d);
                    } else { 
                        isWormhole = false; 
                        if(audio) audio.updateWormhole(0, d);
                    }
                } else { 
                    isWormhole = false; 
                    if(audio) audio.updateWormhole(0, 5);
                }
                document.getElementById('status').innerText = isWormhole ? "GRAVITY COLLAPSE: WORMHOLE" : "GOD MODE: ACTIVE";
            }
        }

        function convertTo3D(pt) {
            const x = (1-pt.x)*2-1, y = -(pt.y*2-1);
            const v = new THREE.Vector3(x, y, 0.5);
            v.unproject(camera);
            const d = v.sub(camera.position).normalize();
            return camera.position.clone().add(d.multiplyScalar(-camera.position.z / d.z));
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            currentZoom += (targetZoom - currentZoom) * 0.1;
            camera.position.z = currentZoom;

            pulseIntensity *= 0.95;
            nebulaColor.setHSL(0.6 + Math.sin(time)*0.05, 0.5, 0.01 + pulseIntensity * 0.1);
            scene.background = nebulaColor;

            // 1. 惑星物理
            const posArr = planetParticles.geometry.attributes.position.array;
            const baseArr = planetParticles.geometry.attributes.basePosition.array;
            const velArr = planetParticles.geometry.attributes.velocity.array;
            for (let i = 0; i < PLANET_PARTICLE_COUNT; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                const p = new THREE.Vector3(posArr[ix], posArr[iy], posArr[iz]);
                const b = new THREE.Vector3(baseArr[ix], baseArr[iy], baseArr[iz]);
                b.applyAxisAngle(new THREE.Vector3(0,1,0), 0.003);
                baseArr[ix]=b.x; baseArr[iy]=b.y; baseArr[iz]=b.z;

                let f = new THREE.Vector3();
                if(isWormhole) {
                    const toW = wormholePos.clone().sub(p);
                    f.add(toW.normalize().multiplyScalar(1.5 / (toW.length()+0.2)));
                } else {
                    handPoints.forEach(hp => {
                        const d = p.distanceTo(hp);
                        if(d < 3.0) f.add(p.clone().sub(hp).normalize().multiplyScalar(Math.pow(1-d/3.0,2)*1.0));
                    });
                }
                velArr[ix]=(velArr[ix]+f.x+(b.x-p.x)*0.02)*0.92;
                velArr[iy]=(velArr[iy]+f.y+(b.y-p.y)*0.02)*0.92;
                velArr[iz]=(velArr[iz]+f.z+(b.z-p.z)*0.02)*0.92;
                posArr[ix]+=velArr[ix]; posArr[iy]+=velArr[iy]; posArr[iz]+=velArr[iz];
            }
            planetParticles.geometry.attributes.position.needsUpdate = true;

            // 2. 星空とリング
            ring.rotation.y += 0.012;
            starField.rotation.y += 0.0004;
            const sPos = starField.geometry.attributes.position.array;
            const sInit = starField.geometry.attributes.initialPosition.array;
            for(let i=0; i<STAR_COUNT; i++) {
                const ix = i*3, iy = i*3+1;
                if(isWormhole) {
                    const dx = wormholePos.x-sPos[ix], dy = wormholePos.y-sPos[iy];
                    const dist = Math.sqrt(dx*dx+dy*dy);
                    sPos[ix]+=dx*(0.3/(dist+1.5)); sPos[iy]+=dy*(0.3/(dist+1.5));
                }
                sPos[ix]+=(sInit[ix]-sPos[ix])*0.05; sPos[iy]+=(sInit[iy]-sPos[iy])*0.05;
            }
            starField.geometry.attributes.position.needsUpdate = true;

            // 3. その他惑星更新
            extraPlanets.forEach(p => {
                if(!p.userData.isPopped) {
                    p.position.add(p.userData.vel); p.rotation.x += 0.015;
                    handPoints.forEach(hp => {
                        if(p.position.distanceTo(hp) < p.userData.size + 1.0) {
                            p.userData.isPopped = true; p.visible = false;
                            if(audio) audio.playPop();
                            setTimeout(() => { p.userData.isPopped = false; p.visible = true; p.position.copy(p.userData.originalPos); }, 5000);
                        }
                    });
                }
            });

            // 4. トレイルと流星
            for(let i=trailParticles.length-1; i>=0; i--) {
                const tp = trailParticles[i]; tp.life -= 0.03; tp.mesh.position.add(tp.vel);
                tp.mesh.material.opacity = tp.life; tp.mesh.scale.setScalar(tp.life);
                if(tp.life <= 0) { scene.remove(tp.mesh); trailParticles.splice(i,1); }
            }
            for(let i=shootingStars.length-1; i>=0; i--) {
                const ss = shootingStars[i]; ss.mesh.translateZ(3.0); ss.life -= 0.015;
                if(ss.life <= 0 || ss.mesh.position.z > 80) { scene.remove(ss.mesh); shootingStars.splice(i,1); }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>